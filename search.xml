<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[yii2 阿里云 短信服务 aliyun_dysms [ 2.0 版本 ]]]></title>
    <url>%2F2018%2F06%2F23%2Faliyun-dysms%2F</url>
    <content type="text"><![CDATA[aliyun-dysms安装1composer require "saviorlv/yii2-dysms:dev-master" or添加下列代码在composer.json文件中并执行composer update 操作 12345&#123; "require": &#123; "saviorlv/yii2-dysms":"dev-master" &#125;&#125; 设置方法全局使用 在config/main.php配置文件中定义component配置信息123456789'components' =&gt; [ ..... 'aliyun' =&gt; [ 'class' =&gt; 'saviorlv\aliyun\Sms', 'accessKeyId' =&gt; '123455', 'accessKeySecret' =&gt; '122345666' ], ....] 代码中调用（调用短信发送接口示例） 1234567891011$response = Yii::$app-&gt;aliyun-&gt;sendSms( "孙坤峰", // 短信签名 "SMS_76350132", // 短信模板编号 "13673715134", // 短信接收者 Array( // 短信模板中字段的值 "code"=&gt;"12345", "product"=&gt;"dsd" ), "123" ); print_r($response); Yii2专属 新的链接地址通用包 新的链接地址]]></content>
      <categories>
        <category>阿里云</category>
      </categories>
      <tags>
        <tag>alyun</tag>
        <tag>sms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yii2 阿里云 OSS服务 aliyun_oss [ 2.0 版本 ]]]></title>
    <url>%2F2018%2F06%2F23%2Faliyun-oss%2F</url>
    <content type="text"><![CDATA[Yii2 阿里云 OSS安装 1composer require mrk/yii2-aliyun-oss:@dev or add 1&quot;mrk/yii2-aliyun-oss&quot;:&quot;@dev&quot; 使用 在 main.php 文件中做如下修改 123456789components =&gt; [ 'oss' =&gt; [ 'class' =&gt; 'mrk\aliyun\OSS', 'accessKeyId' =&gt; 'xxxxx', // 阿里云AccessKeyID 'accessKeySecret' =&gt; 'xxxx', // 阿里云 AccessKeySecret 'bucket' =&gt; 'xxx', // bucket 'endpoint' =&gt; 'http://oss-cn-hangzhou.aliyuncs.com', //OSS节点地址 ],] 在 controller 中 1\Yii::$app-&gt;oss-&gt;upload($object,$file);]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>aliyun</tag>
        <tag>yii2</tag>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 自带事件的用法]]></title>
    <url>%2F2018%2F06%2F20%2Fyii2-event%2F</url>
    <content type="text"><![CDATA[Model 层 保存之前的事件示例 123456789101112public function beforeSave($insert)&#123; if (parent::beforeSave($insert)) &#123; // 插入新数据判断订单号是否存在 if (!Order::findModel(['trade_no' =&gt; $this-&gt;order_trade_no])) &#123; throw new Exception("订单号不存在"); &#125; return true; &#125; else &#123; return false; &#125;&#125; 保存之后的事件示例 12345678public function afterSave($insert, $changedAttributes)&#123; parent::afterSave($insert, $changedAttributes); if ($insert) &#123; // 插入新数据之后修改订单状态 Order::updateAll(['shipping_status' =&gt; Order::SHIPPING_STATUS1, 'shipping_at' =&gt; time()], ['trade_no' =&gt; $this-&gt;order_trade_no]); &#125;&#125; 删除之后的事件示例 1234public function afterDelete()&#123; parent::afterDelete();&#125; Model 事件怎么保证数据事务呢？添加一下代码在 Model 中: 1234567public function transactions()&#123; return [ self::SCENARIO_DEFAULT =&gt; self::OP_INSERT | self::OP_UPDATE | self::OP_DELETE // self::SCENARIO_DEFAULT =&gt; self::OP_INSERT ];&#125; Controller 层 事件 每次请求之前操作示例 12345678910111213141516/** * @param \yii\base\Action $action * @return bool * @throws \yii\web\BadRequestHttpException */public function beforeAction($action)&#123; if (parent::beforeAction($action)) &#123; $this-&gt;request = Yii::$app-&gt;request; Yii::info($this-&gt;request-&gt;absoluteUrl, '请求地址'); Yii::info($this-&gt;request-&gt;rawBody, '请求数据'); return true; &#125; else &#123; return false; &#125;&#125; 每次请求之后操作示例 1234567891011/** * @param \yii\base\Action $action * @param mixed $result * @return array|mixed * @throws BusinessException */public function afterAction($action, $result)&#123; Yii::info(\yii\helpers\Json::encode($result), '请求返回结果'); return $result;&#125;]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>yii2</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器部署hexo-blog]]></title>
    <url>%2F2017%2F11%2F17%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[第一步： 安装node.js以及本地Hexo初始化本地环境 安装node.jswindows nodejs 官网下载安装地址 1$ brew install node #mac 初始化Hexo博客,首先创建 你的Hexo 目录 12$ mkdir hexo-blog //创建一个自定义的hexo目录$ cd hexo-blog //进入到刚刚创建的目录 然后安装 hexo-cli，安装hexo-cli 如果是Linux系统 需要 root 权限，使用 sudo 运行 12npm install -g hexo-cli //linuxnpm install -g hexo-cli //win 初始化该文件夹 1hexo init 安装hexo的扩展插件 1npm install 等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。 12npm install hexo-deployer-git--savenpm install hexo-server--save 以及一些其他插件（*非必选） 123456npm install hexo-admin--savenpm install hexo-generator-archive--savenpm install hexo-generator-feed--savenpm install hexo-generator-search--savenpm install hexo-generator-tag--savenpm install hexo-generator-sitemap--save 到这里hexo的本地搭建已经基本结束了，快来新建一个文章并在本地启动吧~ 使用 hexo new &lt;文章名称&gt; 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。（*在hexo目录下执行命令） 1hexo new "hello Hexo" 执行该命令后在hexo目录下的 sources/_posts文件夹里生成了刚刚创建的hello 编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo-server 1hexo ghexo server 打开 http://localhost:4000 如果看到 hexo 的初始页面证明安装成功。 生成ssh公钥密钥 1cd ~/.ssh$ ssh-keygen 它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空；具体生产方法可以参考这里 第二步： 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户安装nginx 因为我们是拿nginx做 Web 服务器，所以我们需要安装部署好nginx，如果没有安装，推荐使用LNMP一键安装包 我们可以专门为hexo创建一个部署目录，比如我创建了/home/www/hexo文件夹，并把nginx的配置文件nginx.conf中的部署目录改为/home/www/hexo，配置文件一般在/usr/local/nginx/conf里；同样可以使用默认目录，nginx的默认目录为/var/www/html，如果使用LNMP一键安装包，则默认的部署目录为/home/wwwroot/default 安装git1$ apt-get install git 1,创建一个git用户 12$ sudo adduser git$ passwd git 虽说现在的仓库只有我们自己在使用，新建一个 git 用户显得不是很有必要，但是为了安全起见，还是建议使用单独的 git 用户来专门运行 2,git 服务,添加证书登录 把刚在在本地创建或者已经拥有的公钥，也就是 ~/.ssh/id_rsa.pub 文件里的内容添加到服务器的 /home/git/.ssh/authorized_keys 文件中，如上所说，添加公钥之后可以防止每次 push 都输入密码。（*可以直接执行cat ~/.ssh/id_rsa.pub | pbcopy 复制） 3,初始化 Git 仓库 可以将git仓库放到自定义位置，我是将其放在 /var/repo/blog.git 目录下的 123$ sudo mkdir /var/repo$ cd /var/repo$ sudo git init --bare blog.git 使用 –bare 参数，Git 就会创建一个裸仓库，裸仓库没有工作区，我们不会在裸仓库上进行操作，它只为共享而存在。 4, 配置 git hooks 我们这里要使用的是 post-receive 的 hook，这个 hook 会在整个 git 操作过程完结以后被运行，关于 hooks的详情内容可以参考这里。 在 blog.git/hooks 目录下新建一个 post-receive 文件 12$ cd /var/repo/blog.git/hooks$ vim post-receive 在 post-receive 文件中写入如下内容 12#!/bin/shgit --work-tree=/home/www/hexo --git-dir=/var/repo/blog.git checkout -f 注意，/home/www/hexo 要换成你自己的部署目录，正如上文所说，我是的配置目录是/home/www/hexo。/var/repo/blog.git是git仓库的位置。上面那句 git 命令可以在我们每次 push 完之后，把部署目录更新到博客的最新生成状态。这样便可以完成达到自动部署的目的了。 设置这个文件的可执行权限 1chmod +x post-receive 改变 blog.git 目录的拥有者为 git 用户 1$ sudo chown -R git:git blog.git 禁用 git 用户的 shell 登录权限出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑 /etc/passwd 来实现 1vim /etc/passwd 将 1git:x:1001:1001:,,,:/home/git:/bin/bash 改成 1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 sehll。 第三步： 使用Git自动化部署发布博客1, 配置本地_config.yml文件,完成自动化部署 现在配置 hexo 的 deploy。 修改 hexo 目录下的 _config.yml 找到 deploy, 修改为： 1234deploy: type: git repo:git@ip:/var/repo/blog.git branch:master repo 的地址为你自己的地址以及 git 仓库目录至此，我们的 hexo 自动部署已经全部配置好了 开始使用新建文章： 1$ hexo new post "name" 生成 &amp; 部署： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>linux</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[server-send-file]]></title>
    <url>%2F2017%2F10%2F31%2Fserver-send-file%2F</url>
    <content type="text"><![CDATA[rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 rsync是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。 语法123456rsync [OPTION]... SRC DESTrsync[OPTION]... SRC [USER@]host:DESTrsync[OPTION]... [USER@]HOST:SRC DESTrsync[OPTION]... [USER@]HOST::SRC DESTrsync[OPTION]... SRC [USER@]HOST::DESTrsync[OPTION]...rsync://[USER@]HOST[:PORT]/SRC [DEST] 对应于以上六种命令格式，rsync有六种不同的工作模式： 拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号”:”分隔符时就启动这种工作模式。如：rsync -a /data /backup 使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号”:”分隔符时启动该模式。如：rsync -avz *.c foo:src 使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号”:”分隔符时启动该模式。如：rsync -avz foo:src/bar /data 从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。如：rsync -av root@192.168.78.192::www /databack 从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。如：rsync -av /databack root@192.168.78.192::www 列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www 选项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-v, --verbose 详细模式输出。-q, --quiet 精简输出模式。-c, --checksum 打开校验开关，强制对文件传输进行校验。-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。-r, --recursive 对子目录以递归模式处理。-R, --relative 使用相对路径信息。-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。--backup-dir 将备份文件(如~filename)存放在在目录下。-suffix=SUFFIX 定义备份文件前缀。-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。-l, --links 保留软链结。-L, --copy-links 想对待常规文件一样处理软链结。--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结。--safe-links 忽略指向SRC路径目录树以外的链结。-H, --hard-links 保留硬链结。-p, --perms 保持文件权限。-o, --owner 保持文件属主信息。-g, --group 保持文件属组信息。-D, --devices 保持设备文件信息。-t, --times 保持文件时间信息。-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间。-n, --dry-run现实哪些文件将被传输。-w, --whole-file 拷贝文件，不进行增量检测。-x, --one-file-system 不要跨越文件系统边界。-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节。-e, --rsh=command 指定使用rsh、ssh方式进行数据同步。--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。--delete 删除那些DST中SRC没有的文件。--delete-excluded 同样删除接收端那些被该选项指定排除的文件。--delete-after 传输结束以后再删除。--ignore-errors 及时出现IO错误也进行删除。--max-delete=NUM 最多删除NUM个文件。--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。--force 强制删除目录，即使不为空。--numeric-ids 不将数字的用户和组id匹配为用户名和组名。--timeout=timeip超时时间，单位为秒。-I, --ignore-times 不跳过那些有同样的时间和长度的文件。--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。-T --temp-dir=DIR 在DIR中创建临时文件。--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份。-P 等同于 --partial。--progress 显示备份过程。-z, --compress 对备份的文件在传输时进行压缩处理。--exclude=PATTERN 指定排除不需要传输的文件模式。--include=PATTERN 指定不排除而需要传输的文件模式。--exclude-from=FILE 排除FILE中指定模式的文件。--include-from=FILE 不排除FILE指定模式匹配的文件。--version 打印版本信息。--address 绑定到特定的地址。--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件。--port=PORT 指定其他的rsync服务端口。--blocking-io 对远程shell使用阻塞IO。-stats 给出某些文件的传输状态。--progress 在传输时现实传输过程。--log-format=formAT 指定日志文件格式。--password-file=FILE 从FILE中得到密码。--bwlimit=KBPS 限制I/O带宽，KBytes per second。-h, --help 显示帮助信息。 实例SSH方式首先在服务端启动ssh服务： 1servicesshd start启动 sshd： [确定] 使用rsync进行同步 接下来就可以在客户端使用rsync命令来备份服务端上的数据了，SSH方式是通过系统用户来进行备份的，如下： 1rsync -vzrtopg --progress -e ssh --delete work@172.16.78.192:/www/* /databack/experiment/rsyncwork@172.16.78.192's password:receiving file list ...5 files to considertest/a0 100% 0.00kB/s 527:35:41 (1, 20.0% of 5)b67 100% 65.43kB/s 0:00:00 (2, 40.0% of 5)c0 100% 0.00kB/s 527:35:41 (3, 60.0% of 5)dd100663296 100% 42.22MB/s 0:00:02 (4, 80.0% of 5)sent 96 bytes received 98190 bytes 11563.06 bytes/sectotal size is 100663363 speedup is 1024.19 上面的信息描述了整个的备份过程，以及总共备份数据的大小。 后台服务方式 启动rsync服务，编辑/etc/xinetd.d/rsync文件，将其中的disable=yes改为disable=no，并重启xinetd服务，如下： 123vi /etc/xinetd.d/rsync#default: off# description: The rsync server is a good addition to an ftp server, as it \# allows crc checksumming etc.service rsync &#123;disable = nosocket_type = streamwait = nouser = rootserver = /usr/bin/rsyncserver_args = --daemonlog_on_failure += USERID&#125;/etc/init.d/xinetd restart停止 xinetd： [确定]启动 xinetd： [确定] 创建配置文件，默认安装好rsync程序后，并不会自动创建rsync的主配置文件，需要手工来创建，其主配置文件为“/etc/rsyncd.conf”，创建该文件并插入如下内容： 1vi /etc/rsyncd.confuid=rootgid=rootmax connections=4log file=/var/log/rsyncd.logpid file=/var/run/rsyncd.pidlock file=/var/run/rsyncd.locksecrets file=/etc/rsyncd.passwdhosts deny=172.16.78.0/22[www]comment= backup webpath=/wwwread only = noexclude=testauth users=work 创建密码文件，采用这种方式不能使用系统用户对客户端进行认证，所以需要创建一个密码文件，其格式为“username:password”，用户名可以和密码可以随便定义，最好不要和系统帐户一致，同时要把创建的密码文件权限设置为600，这在前面的模块参数做了详细介绍。 1echo "work:abc123" &gt; /etc/rsyncd.passwdchmod 600 /etc/rsyncd.passwd 备份 完成以上工作，现在就可以对数据进行备份了，如下： 1rsync -avz --progress --delete work@172.16.78.192::www /databack/experiment/rsyncPassword:receiving file list ...6 files to consider./ files...a0 100% 0.00kB/s 528:20:41 (1, 50.0% of 6)b67 100% 65.43kB/s 0:00:00 (2, 66.7% of 6)c0 100% 0.00kB/s 528:20:41 (3, 83.3% of 6)dd100663296 100% 37.49MB/s 0:00:02 (4, 100.0% of 6)sent 172 bytes received 98276 bytes 17899.64 bytes/sectotal size is 150995011 speedup is 1533.75 恢复 当服务器的数据出现问题时，那么这时就需要通过客户端的数据对服务端进行恢复，但前提是服务端允许客户端有写入权限，否则也不能在客户端直接对服务端进行恢复，使用rsync对数据进行恢复的方法如下： 1rsync -avz --progress /databack/experiment/rsync/ work@172.16.78.192::wwwPassword:building file list ...6 files to consider./ab67 100% 0.00kB/s 0:00:00 (2, 66.7% of 6)csent 258 bytes received 76 bytes 95.43 bytes/sectotal size is 150995011 speedup is 452080.87]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 忘记MySQL密码解决办法]]></title>
    <url>%2F2017%2F09%2F09%2Fcentos-forget-mysql-password%2F</url>
    <content type="text"><![CDATA[首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。因为在重新设置MySQL的root密码的期间，MySQL数据库完全出于没有密码保护的状态下，其他的用户也可以任意地登录和修改MySQL的信息。可以采用将MySQL对外的端口封闭。 修改MySQL的登录设置：1# vim /etc/my.cnf 在[mysqld]的段中加上一句：skip-grant-tables,如下： 1234[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockskip-grant-tables 保存并且退出vi。 重新启动mysqld1# systemctl restart mysqld.service 登录并修改MySQL的root密码123456789101112# mysqlWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3 to server version: 3.23.56Type 'help;' or '\h' for help. Type '\c' to clear the buffer.mysql&gt; USE mysql ;Database changedmysql&gt; UPDATE user SET Password = password ( 'password' ) WHERE User = 'root' ;Query OK, 0 rows affected (0.00 sec)Rows matched: 2 Changed: 0 Warnings: 0mysql&gt; flush privileges ;Query OK, 0 rows affected (0.01 sec)mysql&gt; quit 将MySQL的登录设置修改回来1# vim /etc/my.cnf 将刚才在[mysqld]的段中加上的skip-grant-tables删除,保存并且退出vim. 重新启动mysqld1# systemctl restart mysqld.service]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yii2-ActiveRecord]]></title>
    <url>%2F2017%2F08%2F29%2Fyii2-ActiveRecord%2F</url>
    <content type="text"><![CDATA[简介 Yii 在操作数据库方面提供了一个十分强大的类库来支撑整个框架业务的运转，这就是 Active Record （活动记录，以下简称AR）。 基本概念 AR类提供了一个面向对象的接口， 用以访问数据库中的数据。例如，假定 Customer AR 类关联着 customer 表，且该类的 name 属性代表 customer 表的 name 列。 你可以写以下代码来哉customer 表里插入一行新的记录: 用 AR 而不是原生的 SQL 语句去执行数据库查询，可以调用直观方法来实现相同目标。如，调用 yiidbActiveRecord::save() 方法将执行插入或更新轮询，将在该 AR 类关联的数据表新建或更新一行数据： 123$customer = new Customer();$customer-&gt;name = 'Qiang';$customer-&gt;save(); // 一行新数据插入 customer 表 上面的代码和使用下面的原生 SQL 语句是等效的，但显然前者更直观， 更不易出错，并且面对不同的数据库系统（DBMS, Database Management System）时更不容易产生兼容性问题。 123$db-&gt;createCommand('INSERT INTO customer (name) VALUES (:name)', [ ':name' =&gt; 'Qiang',])-&gt;execute(); 下面是所有目前被 Yii 的 AR 功能所支持的数据库列表：MySQL 4.1 及以上：通过 yiidbActiveRecordPostgreSQL 7.3 及以上：通过 yiidbActiveRecordSQLite 2 和 3：通过 yiidbActiveRecordMicrosoft SQL Server 2010 及以上：通过 yiidbActiveRecordOracle: 通过 yiidbActiveRecordCUBRID 9.1 及以上：通过 yiidbActiveRecordSphinx：通过 yiisphinxActiveRecord，需求 yii2-sphinx 扩展ElasticSearch：通过 yiielasticsearchActiveRecord，需求 yii2-elasticsearch 扩展Redis 2.6.12 及以上：通过 yiiredisActiveRecord，需求 yii2-redis 扩展MongoDB 1.3.0 及以上：通过 yiimongodbActiveRecord，需求 yii2-mongodb 扩展如你所见，Yii 不仅提供了对关系型数据库的 AR 支持，还提供了 NoSQL 数据库的支持。 声明 AR 类 要想声明一个 AR 类，你需要扩展 yiidbActiveRecord 基类， 并实现 tableName 方法，返回与之相关联的的数据表的名称： 12345678910111213namespace app\models;use yii\db\ActiveRecord;class Customer extends ActiveRecord&#123; /** * @return string 返回该AR类关联的数据表名 */ public static function tableName() &#123; return 'customer'; &#125;&#125; 访问列数据 AR 把相应数据行的每一个字段映射为 AR 对象的一个个特性变量（Attribute） 一个特性就好像一个普通对象的公共属性一样（public property）。特性变量的名称和对应字段的名称是一样的，且大小姓名。 使用以下语法读取列的值： 1234567// "id" 和 "mail" 是 $customer 对象所关联的数据表的对应字段名$id = $customer-&gt;id;$email = $customer-&gt;email;要改变列值，只要给关联属性赋新值并保存对象即可：$customer-&gt;email = 'james@example.com';$customer-&gt;save(); 建立数据库连接 AR 用一个 yiidbConnection 对象与数据库交换数据。默认的，它使用 db 组件作为其连接对象，你可以在应用程序配置文件中设置下 db 组件，就像这样： 12345678910return [ 'components' =&gt; [ 'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'dsn' =&gt; 'mysql:host=localhost;dbname=testdb', 'username' =&gt; 'demo', 'password' =&gt; 'demo', ], ],]; 如果在你的应用中应用了不止一个数据库，且你需要给你的 AR 类使用不同的数据库链接（DB connection） ，你可以覆盖掉 yiidbActiveRecord::getDb() 方法： 1234567class Customer extends ActiveRecord&#123; // ... public static function getDb() &#123; return \Yii::$app-&gt;db2; // 使用名为 "db2" 的应用组件 &#125;&#125; 查询数据 AR 提供了两种方法来构建 DB 查询并向 AR 实例里填充数据： 12yiidbActiveRecord::find()yiidbActiveRecord::findBySql() 以上两个方法都会返回 yiidbActiveQuery 实例，该类继承自yiidbQuery， 因此，他们都支持同一套灵活且强大的 DB 查询方法，如where()，join()，orderBy()，等等。 下面的这些案例展示了一些可能的玩法： 1234567891011121314151617181920212223// 取回所有活跃客户(状态为 *active* 的客户）并以他们的 ID 排序：$customers = Customer::find() -&gt;where(['status' =&gt; Customer::STATUS_ACTIVE]) -&gt;orderBy('id') -&gt;all();// 返回ID为1的客户：$customer = Customer::find() -&gt;where(['id' =&gt; 1]) -&gt;one();// 取回活跃客户的数量：$count = Customer::find() -&gt;where(['status' =&gt; Customer::STATUS_ACTIVE]) -&gt;count();// 以客户ID索引结果集：// $customers 数组以 ID 为索引$customers = Customer::find()-&gt;indexBy('id')-&gt;all();// 用原生 SQL 语句检索客户：$sql = 'SELECT * FROM customer';$customers = Customer::findBySql($sql)-&gt;all(); 小技巧：在上面的代码中，Customer::STATUS_ACTIVE 是一个在 Customer 类里定义的常量。（译注：这种常量的值一般都是tinyint）相较于直接在代码中写死字符串或数字，使用一个更有意义的常量名称是一种更好的编程习惯。 有两个快捷方法：findOne 和 findAll() 用来返回一个或者一组ActiveRecord实例。前者返回第一个匹配到的实例，后者返回所有。 例如： 12345678910111213141516// 返回 id 为 1 的客户$customer = Customer::findOne(1);// 返回 id 为 1 且状态为 *active* 的客户$customer = Customer::findOne([ 'id' =&gt; 1, 'status' =&gt; Customer::STATUS_ACTIVE,]);// 返回id为1、2、3的一组客户$customers = Customer::findAll([1, 2, 3]);// 返回所有状态为 "deleted" 的客户$customer = Customer::findAll([ 'status' =&gt; Customer::STATUS_DELETED,]); 以数组形式获取数据 有时候，我们需要处理很大量的数据，这时可能需要用一个数组来存储取到的数据， 从而节省内存。 你可以用 asArray() 函数做到这一点： 12345// 以数组而不是对象形式取回客户信息：$customers = Customer::find() -&gt;asArray() -&gt;all();// $customers 的每个元素都是键值对数组 批量获取数据 在 Query Builder（查询构造器） 里，我们已经解释了当需要从数据库中查询大量数据时，你可以用 batch query（批量查询）来限制内存的占用。 你可能也想在 AR 里使用相同的技巧，比如这样…… 123456789101112// 一次提取 10 个客户信息foreach (Customer::find()-&gt;batch(10) as $customers) &#123; // $customers 是 10 个或更少的客户对象的数组&#125;// 一次提取 10 个客户并一个一个地遍历处理foreach (Customer::find()-&gt;each(10) as $customer) &#123; // $customer 是一个 ”Customer“ 对象&#125;// 贪婪加载模式的批处理查询foreach (Customer::find()-&gt;with('orders')-&gt;each() as $customer) &#123;&#125; 操作数据(CURD) AR 提供以下方法插入、更新和删除与 AR 对象关联的那张表中的某一行： 1234yiidbActiveRecord::save()yiidbActiveRecord::insert()yiidbActiveRecord::update()yiidbActiveRecord::delete() AR 同时提供了一些静态方法，可以应用在与某 AR 类所关联的整张表上。用这些方法的时候千万要小心，因为他们作用于整张表！比如，deleteAll() 会删除掉表里所有的记录。 1234yiidbActiveRecord::updateCounters()yiidbActiveRecord::updateAll()yiidbActiveRecord::updateAllCounters()yiidbActiveRecord::deleteAll() 下面的这些例子里，详细展现了如何使用这些方法： 1234567891011121314151617181920212223// 插入新客户的记录$customer = new Customer();$customer-&gt;name = 'James';$customer-&gt;email = 'james@example.com';$customer-&gt;save(); // 等同于 $customer-&gt;insert();// 更新现有客户记录$customer = Customer::findOne($id);$customer-&gt;email = 'james@example.com';$customer-&gt;save(); // 等同于 $customer-&gt;update();// 删除已有客户记录$customer = Customer::findOne($id);$customer-&gt;delete();// 删除多个年龄大于20，性别为男（Male）的客户记录Customer::deleteAll( 'age &gt; :age AND gender = :gender', [':age' =&gt; 20, ':gender' =&gt; 'M']);// 所有客户的age（年龄）字段加1：Customer::updateAllCounters(['age' =&gt; 1]); 须知：save() 方法会调用 insert() 和 update() 中的一个， 用哪个取决于当前 AR 对象是不是新对象（在函数内部，他会检查 yiidbActiveRecord::isNewRecord 的值）。 若 AR 对象是由 new 操作符 初始化出来的，save() 方法会在表里插入一条数据； 如果一个 AR 是由 find() 方法获取来的， 则 save() 会更新表里的对应行记录。 数据输入与有效性验证 由于AR继承自yiibaseModel，所以它同样也支持Model的数据输入、验证等特性。 例如，你可以声明一个rules方法用来覆盖掉yiibaseModel::rules()里的；你也可以给AR实例批量赋值；你也可以通过调用yiibaseModel::validate()执行数据验证。 当你调用 save()、insert()、update() 这三个方法时，会自动调用yiibaseModel::validate()方法。如果验证失败，数据将不会保存进数据库。 下面的例子演示了如何使用AR 获取/验证用户输入的数据并将他们保存进数据库： 1234567891011121314// 新建一条记录$model = new Customer;if ($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;save()) &#123; // 获取用户输入的数据，验证并保存&#125;// 更新主键为$id的AR$model = Customer::findOne($id);if ($model === null) &#123; throw new NotFoundHttpException;&#125;if ($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;save()) &#123; // 获取用户输入的数据，验证并保存&#125; 读取默认值 你的表列也许定义了默认值。有时候，你可能需要在使用web表单的时候给AR预设一些值。 如果你需要这样做，可以在显示表单内容前通过调用loadDefaultValues()方法来实现： 12345&lt;?php $customer = new Customer(); $customer-&gt;loadDefaultValues(); // ... 渲染 $customer 的 HTML 表单 ...?&gt; ` AR的生命周期 理解AR的生命周期对于你操作数据库非常重要。生命周期通常都会有些典型的事件存在。对于开发AR的behaviors来说非常有用。 当你实例化一个新的AR对象时，我们将获得如下的生命周期： 123456789101112131415161718191. constructor2. yii\db\ActiveRecord::init(): 会触发一个 yii\db\ActiveRecord::EVENT_INIT 事件当你通过 yiidbActiveRecord::find() 方法查询数据时，每个AR实例都将有以下生命周期：1. constructor2. yii\db\ActiveRecord::init(): 会触发一个 yii\db\ActiveRecord::EVENT_INIT 事件3. yii\db\ActiveRecord::afterFind(): 会触发一个 yii\db\ActiveRecord::EVENT_AFTER_FIND 事件当通过 yiidbActiveRecord::save() 方法写入或者更新数据时, 我们将获得如下生命周期：1. yii\db\ActiveRecord::beforeValidate(): 会触发一个 yii\db\ActiveRecord::EVENT_BEFORE_VALIDATE 事件2. yii\db\ActiveRecord::afterValidate(): 会触发一个 yii\db\ActiveRecord::EVENT_AFTER_VALIDATE 事件3. yii\db\ActiveRecord::beforeSave(): 会触发一个 yii\db\ActiveRecord::EVENT_BEFORE_INSERT 或 yii\db\ActiveRecord::EVENT_BEFORE_UPDATE 事件4. 执行实际的数据写入或更新5. yii\db\ActiveRecord::afterSave(): 会触发一个 yii\db\ActiveRecord::EVENT_AFTER_INSERT 或 yii\db\ActiveRecord::EVENT_AFTER_UPDATE 事件最后，当调用 yiidbActiveRecord::delete() 删除数据时, 我们将获得如下生命周期：1. yii\db\ActiveRecord::beforeDelete(): 会触发一个 yii\db\ActiveRecord::EVENT_BEFORE_DELETE 事件2. 执行实际的数据删除3. yii\db\ActiveRecord::afterDelete(): 会触发一个 yii\db\ActiveRecord::EVENT_AFTER_DELETE 事件 查询关联的数据 使用 AR 方法也可以查询数据表的关联数据（如，选出表A的数据可以拉出表B的关联数据）。有了 AR， 返回的关联数据连接就像连接关联主表的 AR 对象的属性一样。建立关联关系后，通过 $customer-&gt;orders 可以获取 一个 Order 对象的数组，该数组代表当前客户对象的订单集。定义关联关系使用一个可以返回 yiidbActiveQuery 对象的 getter 方法， yiidbActiveQuery对象有关联上下文的相关信息，因此可以只查询关联数据。例如： 12345678910111213class Customer extends \yii\db\ActiveRecord&#123; public function getOrders() &#123; // 客户和订单通过 Order.customer_id -&gt; id 关联建立一对多关系 return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']); &#125; &#125; class Order extends \yii\db\ActiveRecord&#123; // 订单和客户通过 Customer.id -&gt; customer_id 关联建立一对一关系 public function getCustomer() &#123; return $this-&gt;hasOne(Customer::className(), ['id' =&gt; 'customer_id']); &#125; &#125; 以上使用了 yiidbActiveRecord::hasMany() 和 yiidbActiveRecord::hasOne() 方法。以上两例分别是关联数据多对一关系和一对一关系的建模范例。 如，一个客户有很多订单，一个订单只归属一个客户。两个方法都有两个参数并返回 yiidbActiveQuery 对象。$class：关联模型类名，它必须是一个完全合格的类名。$link: 两个表的关联列，应为键值对数组的形式。 数组的键是 $class 关联表的列名， 而数组值是关联类 $class 的列名。 基于表外键定义关联关系是最佳方法。建立关联关系后，获取关联数据和获取组件属性一样简单， 执行以下相应getter方法即可： 123// 取得客户的订单$customer = Customer::findOne(1);$orders = $customer-&gt;orders; // $orders 是 Order 对象数组 以上代码实际执行了以下两条 SQL 语句： SELECT FROM customer WHERE id=1;SELECT FROM order WHERE customer_id=1;提示:再次用表达式 $customer-&gt;orders将不会执行第二次 SQL 查询， SQL 查询只在该表达式第一次使用时执行。 数据库访问只返回缓存在内部前一次取回的结果集，如果你想查询新的 关联数据，先要注销现有结果集：unset($customer-&gt;orders);。有时候需要在关联查询中传递参数，如不需要返回客户全部订单， 只需要返回购买金额超过设定值的大订单， 通过以下getter方法声明一个关联数据 bigOrders ： 1234567class Customer extends \yii\db\ActiveRecord&#123; public function getBigOrders($threshold = 100) &#123; return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']) -&gt;where('subtotal &gt; :threshold', [':threshold' =&gt; $threshold]) -&gt;orderBy('id'); &#125; &#125; hasMany() 返回 yiidbActiveQuery 对象，该对象允许你通过 yiidbActiveQuery 方法定制查询。如上声明后，执行 $customer-&gt;bigOrders 就返回 总额大于100的订单。使用以下代码更改设定值： $orders = $customer-&gt;getBigOrders(200)-&gt;all();注意：关联查询返回的是 yiidbActiveQuery 的实例，如果像特性（如类属性）那样连接关联数据， 返回的结果是关联查询的结果，即 yiidbActiveRecord 的实例， 或者是数组，或者是 null ，取决于关联关系的多样性。如，$customer-&gt;getOrders() 返回ActiveQuery 实例，而 $customer-&gt;orders 返回Order 对象数组 （如果查询结果为空则返回空数组）。中间关联表有时，两个表通过中间表关联，定义这样的关联关系， 可以通过调用 yiidbActiveQuery::via() 方法或 yiidbActiveQuery::viaTable() 方法来定制 yiidbActiveQuery 对象 。 举例而言，如果 order 表和 item 表通过中间表 order_item 关联起来， 可以在 Order 类声明 items 关联关系取代中间表： 123456class Order extends \yii\db\ActiveRecord&#123; public function getItems() &#123; return $this-&gt;hasMany(Item::className(), ['id' =&gt; 'item_id']) -&gt;viaTable('order_item', ['order_id' =&gt; 'id']); &#125; &#125; 两个方法是相似的，除了 yiidbActiveQuery::via() 方法的第一个参数是使用 AR 类中定义的关联名。 以上方法取代了中间表，等价于： 123456789101112class Order extends \yii\db\ActiveRecord&#123; public function getOrderItems() &#123; return $this-&gt;hasMany(OrderItem::className(), ['order_id' =&gt; 'id']); &#125; public function getItems() &#123; return $this-&gt;hasMany(Item::className(), ['id' =&gt; 'item_id']) -&gt;via('orderItems'); &#125;&#125; 延迟加载和即时加载（又称惰性加载与贪婪加载）如前所述，当你第一次连接关联对象时， AR 将执行一个数据库查询 来检索请求数据并填充到关联对象的相应属性。如果再次连接相同的关联对象，不再执行任何查询语句，这种数据库查询的执行方法称为“延迟加载”。如： 123456// SQL executed: SELECT * FROM customer WHERE id=1$customer = Customer::findOne(1);// SQL executed: SELECT * FROM order WHERE customer_id=1$orders = $customer-&gt;orders;// 没有 SQL 语句被执行$orders2 = $customer-&gt;orders; //取回上次查询的缓存数据延迟加载非常实用，但是，在以下场景中使用延迟加载会遭遇性能 问题： 12345678// SQL executed: SELECT * FROM customer LIMIT 100$customers = Customer::find()-&gt;limit(100)-&gt;all();foreach ($customers as $customer) &#123; // SQL executed: SELECT * FROM order WHERE customer_id=... $orders = $customer-&gt;orders; // ...处理 $orders...&#125; 假设数据库查出的客户超过100个，以上代码将执行多少条 SQL 语句？ 101 条！第一条 SQL 查询语句取回100个客户，然后， 每个客户要执行一条 SQL 查询语句以取回该客户的所有订单。 为解决以上性能问题，可以通过调用 yiidbActiveQuery::with() 方法使用即时加载解决。 12345678910// SQL executed: SELECT * FROM customer LIMIT 100;// SELECT * FROM orders WHERE customer_id IN (1,2,...)$customers = Customer::find()-&gt;limit(100) -&gt;with('orders')-&gt;all();foreach ($customers as $customer) &#123; // 没有 SQL 语句被执行 $orders = $customer-&gt;orders; // ...处理 $orders...&#125; 如你所见，同样的任务只需要两个 SQL 语句。 须知：通常，即时加载 N 个关联关系而通过 via() 或者 viaTable() 定义了 M 个关联关系， 将有 1+M+N 条 SQL 查询语句被执行：一个查询取回主表行数， 一个查询给每一个 (M) 中间表，一个查询给每个 (N) 关联表。注意:当用即时加载定制 select() 时，确保连接 到关联模型的列都被包括了，否则，关联模型不会载入。如： 123456$orders = Order::find() -&gt;select(['id', 'amount']) -&gt;with('customer') -&gt;all(); // $orders[0]-&gt;customer 总是空的，使用以下代码解决这个 问题： 1234$orders = Order::find() -&gt;select(['id', 'amount', 'customer_id']) -&gt;with('customer') -&gt;all(); 有时候，你想自由的自定义关联查询，延迟加载和即时加载都可以实现，如： 1234567891011121314$customer = Customer::findOne(1);// 延迟加载: SELECT * FROM order WHERE customer_id=1 AND subtotal&gt;100$orders = $customer-&gt;getOrders()-&gt;where('subtotal&gt;100')-&gt;all();// 即时加载: SELECT * FROM customer LIMIT 100// SELECT * FROM order WHERE customer_id IN (1,2,...) AND subtotal&gt;100$customers = Customer::find() -&gt;limit(100) -&gt;with([ 'orders' =&gt; function($query) &#123; $query-&gt;andWhere('subtotal&gt;100'); &#125;, ]) -&gt;all(); 逆关系关联关系通常成对定义，如：Customer 可以有个名为 orders 关联项， 而 Order 也有个名为customer 的关联项： 12345678910111213class Customer extends ActiveRecord&#123; .... public function getOrders() &#123; return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']); &#125; &#125; class Order extends ActiveRecord&#123; .... public function getCustomer() &#123; return $this-&gt;hasOne(Customer::className(), ['id' =&gt; 'customer_id']); &#125; &#125; 如果我们执行以下查询，可以发现订单的 customer 和 找到这些订单的客户对象并不是同一个。 连接 customer-&gt;orders 将触发一条 SQL 语句 而连接一个订单的 customer 将触发另一条 SQL 语句。 12345678910// SELECT * FROM customer WHERE id=1$customer = Customer::findOne(1);// 输出 "不相同"// SELECT * FROM order WHERE customer_id=1// SELECT * FROM customer WHERE id=1if ($customer-&gt;orders[0]-&gt;customer === $customer) &#123; echo '相同';&#125; else &#123; echo '不相同';&#125; 为避免多余执行的后一条语句，我们可以为 customer或 orders 关联关系定义相反的关联关系，通过调用 yiidbActiveQuery::inverseOf() 方法可以实现。 1234567class Customer extends ActiveRecord&#123; .... public function getOrders() &#123; return $this-&gt;hasMany(Order::className(), ['customer_id' =&gt; 'id']) -&gt;inverseOf('customer'); &#125; &#125; 现在我们同样执行上面的查询，我们将得到： 123456789// SELECT * FROM customer WHERE id=1$customer = Customer::findOne(1);// 输出相同// SELECT * FROM order WHERE customer_id=1if ($customer-&gt;orders[0]-&gt;customer === $customer) &#123; echo '相同';&#125; else &#123; echo '不相同';&#125; 以上我们展示了如何在延迟加载中使用相对关联关系， 相对关系也可以用在即时加载中： 123456789// SELECT * FROM customer// SELECT * FROM order WHERE customer_id IN (1, 2, ...)$customers = Customer::find()-&gt;with('orders')-&gt;all();// 输出相同if ($customers[0]-&gt;orders[0]-&gt;customer === $customers[0]) &#123; echo '相同';&#125; else &#123; echo '不相同';&#125; 注意:相对关系不能在包含中间表的关联关系中定义。即是，如果你的关系是通过yii\db\ActiveQuery::via() 或 yii\db\ActiveQuery::viaTable()方法定义的， 就不能调用yii\db\ActiveQuery::inverseOf()方法了。JOIN 类型关联查询使用关系数据库时，普遍要做的是连接多个表并明确地运用各种 JOIN 查询。JOIN SQL语句的查询条件和参数，使用 yiidbActiveQuery::joinWith() 可以重用已定义关系并调用 而不是使用 yiidbActiveQuery::join() 来实现目标。 123456789// 查找所有订单并以客户 ID 和订单 ID 排序，并贪婪加载 "customer" 表$orders = Order::find() -&gt;joinWith('customer') -&gt;orderBy('customer.id, order.id') -&gt;all();// 查找包括书籍的所有订单，并以 `INNER JOIN` 的连接方式即时加载 "books" 表$orders = Order::find() -&gt;innerJoinWith('books') -&gt;all(); 以上，方法 yiidbActiveQuery::innerJoinWith() 是访问 INNER JOIN 类型的 yiidbActiveQuery::joinWith() 的快捷方式。 可以连接一个或多个关联关系，可以自由使用查询条件到关联查询， 也可以嵌套连接关联查询。如： 123456789101112131415// 连接多重关系// 找出24小时内注册客户包含书籍的订单$orders = Order::find() -&gt;innerJoinWith([ 'books', 'customer' =&gt; function ($query) &#123; $query-&gt;where('customer.created_at &gt; ' . (time() - 24 * 3600)); &#125; ]) -&gt;all(); // 连接嵌套关系：连接 books 表及其 author 列$orders = Order::find() -&gt;joinWith('books.author') -&gt;all(); 代码背后， Yii 先执行一条 JOIN SQL 语句把满足 JOIN SQL 语句查询条件的主要模型查出， 然后为每个关系执行一条查询语句， bing填充相应的关联记录。yii\db\ActiveQuery::joinWith() 和 yii\db\ActiveQuery::with() 的区别是:前者连接主模型类和关联模型类的数据表来检索主模型， 而后者只查询和检索主模型类。 检索主模型由于这个区别，你可以应用只针对一条 JOIN SQL 语句起效的查询条件。 如，通过关联模型的查询条件过滤主模型，如前例， 可以使用关联表的列来挑选主模型数据，当使用 yii\db\ActiveQuery::joinWith() 方法时可以响应没有歧义的列名。 当连接关联关系时，关联关系默认使用即时加载。 你可以 通过传参数 $eagerLoading 来决定在指定关联查询中是否使用即时加载。 默认 yii\db\ActiveQuery::joinWith() 使用左连接来连接关联表。 你也可以传 $joinType 参数来定制连接类型。 你也可以使用 yii\db\ActiveQuery::innerJoinWith()。以下是 INNER JOIN 的简短例子： // 查找包括书籍的所有订单，但 “books” 表不使用即时加载$orders = Order::find() -&gt;innerJoinWith(‘books’, false) -&gt;all(); // 等价于：$orders = Order::find() -&gt;joinWith(‘books’, false, ‘INNER JOIN’) -&gt;all();有时连接两个表时，需要在关联查询的 ON 部分指定额外条件。这可以通过调用 yiidbActiveQuery::onCondition() 方法实现： class User extends ActiveRecord{ public function getBooks() { return $this-&gt;hasMany(Item::className(), [‘owner_id’ =&gt; ‘id’]) -&gt;onCondition([‘category_id’ =&gt; 1]); }}在上面， yii\db\ActiveRecord::hasMany() 方法回传了一个 yii\db\ActiveQuery 对象， 当你用 yii\db\ActiveQuery::joinWith() 执行一条查询时，取决于正被调用的是哪个 yii\db\ActiveQuery::onCondition()， 返回 category_id 为 1 的 items。当你用 yiidbActiveQuery::joinWith() 进行一次查询时，“on-condition”条件会被放置在相应查询语句的 ON 部分， 如： // SELECT user. FROM user LEFT JOIN item ON item.owner_id=user.id AND category_id=1// SELECT FROM item WHERE owner_id IN (…) AND category_id=1 $users = User::find()-&gt;joinWith(‘books’)-&gt;all();注意：如果通过 yiidbActiveQuery::with() 进行贪婪加载或使用惰性加载的话，则 on 条件会被放置在对应 SQL语句的 WHERE 部分。 因为，此时此处并没有发生 JOIN 查询。比如： // SELECT * FROM user WHERE id=10$user = User::findOne(10); // SELECT * FROM item WHERE owner_id=10 AND category_id=1$books = $user-&gt;books;关联表操作AR 提供了下面两个方法用来建立和解除两个关联对象之间的关系： yiidbActiveRecord::link()yiidbActiveRecord::unlink()例如，给定一个customer和order对象，我们可以通过下面的代码使得customer对象拥有order对象： $customer = Customer::findOne(1); $order = new Order(); $order-&gt;subtotal = 100; $customer-&gt;link(‘orders’, $order);yiidbActiveRecord::link() 调用上述将设置 customer_id 的顺序是 $customer 的主键值，然后调用 yiidbActiveRecord::save() 要将顺序保存到数据库中。作用域当你调用yiidbActiveRecord::find() 或 yiidbActiveRecord::findBySql()方法时，将会返回一个yiidbActiveQuery实例。 之后，你可以调用其他查询方法，如 yiidbActiveQuery::where()，yiidbActiveQuery::orderBy(), 进一步的指定查询条件。 有时候你可能需要在不同的地方使用相同的查询方法。如果出现这种情况，你应该考虑定义所谓的作用域。 作用域是本质上要求一组的查询方法来修改查询对象的自定义查询类中定义的方法。 之后你就可以像使用普通方法一样使用作用域。只需两步即可定义一个作用域。 首先给你的model创建一个自定义的查询类，在此类中定义的所需的范围方法。 例如，给Comment模型创建一个 CommentQuery类，然后在CommentQuery类中定义一个active()的方法为作用域，像下面的代码： 12345678namespace app\models; use yii\db\ActiveQuery; class CommentQuery extends ActiveQuery&#123; public function active($state = true) &#123; $this-&gt;andWhere(['active' =&gt; $state]); return $this; &#125; &#125; 重点:类必须继承 yiidbActiveQuery (或者是其他的 ActiveQuery ，比如 yiimongodbActiveQuery)。必须是一个public类型的方法且必须返回 $this 实现链式操作。可以传入参数。检查 yiidbActiveQuery 对于修改查询条件是非常有用的方法。其次，覆盖yiidbActiveRecord::find() 方法使其返回自定义的查询对象而不是常规的yiidbActiveQuery。 对于上述例子，你需要编写如下代码： 12345678910namespace app\models; use yii\db\ActiveRecord; class Comment extends ActiveRecord&#123; /** * @inheritdoc * @return CommentQuery */ public static function find() &#123; return new CommentQuery(get_called_class()); &#125; &#125; 就这样，现在你可以使用自定义的作用域方法了： 1234567$comments = Comment::find() -&gt;active() -&gt;all(); $inactiveComments = Comment::find() -&gt;active(false) -&gt;all(); 你也能在定义的关联里使用作用域方法，比如： 123456class Post extends \yii\db\ActiveRecord&#123; public function getActiveComments() &#123; return $this-&gt;hasMany(Comment::className(), ['post_id' =&gt; 'id']) -&gt;active(); &#125; &#125; 或者在执行关联查询的时候使用（on-the-fly 是啥？）： 123$posts = Post::find() -&gt;with([ 'comments' =&gt; function($q) &#123; $q-&gt;active(); &#125; ]) -&gt;all(); 默认作用域如果你之前用过 Yii 1.1 就应该知道默认作用域的概念。 一个默认的作用域可以作用于所有查询。 你可以很容易的通过重写yiidbActiveRecord::find()方法来定义一个默认作用域，例如： 1234public static function find()&#123; return parent::find() -&gt;where(['deleted' =&gt; false]); &#125; 注意，你之后所有的查询都不能用 yii\db\ActiveQuery::where()，但是可以用 yii\db\ActiveQuery::andWhere() 和 yii\db\ActiveQuery::orWhere()，他们不会覆盖掉默认作用域。 （译注：如果你要使用默认作用域，就不能在 xxx::find()后使用where()方法，你必须使用andXXX()或者orXXX()系的方法，否则默认作用域不会起效果，至于原因，打开where()方法的代码一看便知） 事务操作 当执行几个相关联的数据库操作的时候 TODO: FIXME: WIP, TBD, https://github.com/yiisoft/yii2/issues/226, yii\db\ActiveRecord::afterSave(), yii\db\ActiveRecord::beforeDelete() and/or yii\db\ActiveRecord::afterDelete()生命周期周期方法(life cycle methods 我觉得这句翻译成“模板方法”会不会更好点？)。 开发者可以通过重写yiidbActiveRecord::save()方法然后在控制器里使用事务操作，严格地说是似乎不是一个好的做法 （召回”瘦控制器 / 肥模型”基本规则）。 这些方法在这里(如果你不明白自己实际在干什么，请不要使用他们)，Models： 12345678910111213class Feature extends \yii\db\ActiveRecord&#123; // ... public function getProduct() &#123; return $this-&gt;hasOne(Product::className(), ['id' =&gt; 'product_id']); &#125; &#125; class Product extends \yii\db\ActiveRecord&#123; // ... public function getFeatures() &#123; return $this-&gt;hasMany(Feature::className(), ['product_id' =&gt; 'id']); &#125; &#125; 重写 yiidbActiveRecord::save() 方法： 123456class ProductController extends \yii\web\Controller&#123; public function actionCreate() &#123; // FIXME: TODO: WIP, TBD &#125;&#125; 在控制器层使用事务： 123456class ProductController extends \yii\web\Controller&#123; public function actionCreate() &#123; // FIXME: TODO: WIP, TBD &#125;&#125; 作为这些脆弱方法的替代，你应该使用原子操作方案特性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Feature extends \yii\db\ActiveRecord&#123; // ... public function getProduct() &#123; return $this-&gt;hasOne(Product::className(), ['product_id' =&gt; 'id']); &#125; public function scenarios() &#123; return [ 'userCreates' =&gt; [ 'attributes' =&gt; ['name', 'value'], 'atomic' =&gt; [self::OP_INSERT], ], ]; &#125;&#125;class Product extends \yii\db\ActiveRecord&#123; // ... public function getFeatures() &#123; return $this-&gt;hasMany(Feature::className(), ['id' =&gt; 'product_id']); &#125; public function scenarios() &#123; return [ 'userCreates' =&gt; [ 'attributes' =&gt; ['title', 'price'], 'atomic' =&gt; [self::OP_INSERT], ], ]; &#125; public function afterValidate() &#123; parent::afterValidate(); // FIXME: TODO: WIP, TBD &#125; public function afterSave($insert) &#123; parent::afterSave($insert); if ($this-&gt;getScenario() === 'userCreates') &#123; // FIXME: TODO: WIP, TBD &#125; &#125;&#125; Controller里的代码将变得很简洁： 123456class ProductController extends \yii\web\Controller&#123; public function actionCreate() &#123; // FIXME: TODO: WIP, TBD &#125;&#125; 控制器非常简洁： 123456class ProductController extends \yii\web\Controller&#123; public function actionCreate() &#123; // FIXME: TODO: WIP, TBD &#125;&#125; 被污染属性 当你调用yiidbActiveRecord::save()用于保存活动记录(Active Record)实例时,只有被污染的属性才会被保存。 一个属性是否认定为被污染取决于它的值自从最后一次从数据库加载或者最近一次保存到数据库后到现在是否被修改过。注意:无论活动记录(Active Record)是否有被污染属性，数据验证始终会执行。 活动记录(Active Record)会自动维护一个污染数据列表。它的工作方式是通过维护一个较旧属性值版本，并且将它们与最新的进行比较。 你可以通过调用yiidbActiveRecord::getDirtyAttributes()来获取当前的污染属性。 你也可以调用yiidbActiveRecord::markAttributeDirty()来显示的标记一个属性为污染属性。 如果你对最近一次修改前的属性值感兴趣，你可以调用yiidbActiveRecord::getOldAttributes() 或 yiidbActiveRecord::getOldAttribute()。]]></content>
      <categories>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-413]]></title>
    <url>%2F2017%2F08%2F28%2Fnginx-413%2F</url>
    <content type="text"><![CDATA[[导读] Nginx出现的413 Request Entity Too Large错误,这个错误一般在上传文件的时候出现，打开nginx主配置文件nginx conf，找到http{}段，修改或者添加。 1client_max_body_size 2m; 然后重启nginx， 1systemctl restart nginx.service 要是以PHP运行的话，这个大小client_max_body_size要和php.ini中的如下值的最大值差不多或者稍大，这样就不会因为提交数据大小不一致出现错误。 12post_max_size = 2Mupload_max_filesize = 2M 重启php-fpm 1systemctl restart php-fpm.service Ok,恢复正常]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-project]]></title>
    <url>%2F2017%2F08%2F14%2Fgit-project%2F</url>
    <content type="text"><![CDATA[在命令行执行 Git 全局设置12git config --global user.name "saviorlv"git config --global user.email "sunkunfeng211@163.com" 创建一个新的仓库123456git clone git@code.aliyun.com:saviorlv/yii2-admin.gitcd yii2-admintouch README.mdgit add README.mdgit commit -m "add README"git push -u origin master 已经存在的文件夹或者git 仓库123456cd existing_foldergit initgit remote add origin git@code.aliyun.com:saviorlv/yii2-admin.gitgit add .git commitgit push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos-svn]]></title>
    <url>%2F2017%2F08%2F07%2Fcentos-svn%2F</url>
    <content type="text"><![CDATA[一、搭建svn环境并创建仓库 1、安装Subversion 1yum install -y subversion 2、检测是否安装成功(查看svn版本号) 1svnserve --version 3、创建版本库 12345678910//先建目录mkdir /var/svnsudo chmod -R 777 /var/svncd /var/svn//创建版本库svnadmin create /var/svn/projectcd projectls -a//自动生成的版本库文件conf db format hooks locks README.txt svn环境搭建成功。 二、配置进入conf目录（该svn版本库配置文件） authz文件是权限控制文件 passwd是帐号密码文件 svnserve.conf SVN服务配置文件 设置帐号密码1sudo vim passwd 在[users]块中添加用户和密码，格式：帐号=密码，如junwei = junwei 完整内容参考下面： 123[users]june = junejunwei = junwei 设置权限1sudo vim authz 完整内容参考下面： 1234567[aliases][groups]admin=june //创建一个组，并制定用户user=june,junwei[/]@admin=rw@user=rw 修改svnserve.conf文件1sudo vim svnserve.conf 完整内容参考下面： 1234567891011[general]anon-access = readauth-access = writepassword-db = passwdauthz-db = authzrealm = /var/svn/project# force-username-case = none[sasl]# use-sasl = true# min-encryption = 0# max-encryption = 256 启动svn版本库 1sudo svnserve -d -r /var/svn 三、实现svn更新自动同步到web目录： 进入/var/svn/project/hooks下，建立post-commit文件： 123456789101112cd /var/svn/project/hooksvim post-commit//在该文件里添加如下代码，保存#!/bin/sh#设定环境变量，如果没有设定可能会出现update报错#设定语言，根据系统语言设置，如果是GBK就设置为 LANG=zh_CN.GBKexport LANG=en_US.utf8SVN_PATH=/usr/bin/svn //这里不用改WEB_PATH=/var/www/html //web目录，如果你的不同，可以改//这里的用户随便一个就好$SVN_PATH update $WEB_PATH --username 'junwei' --password 'junwei' --no-auth-cache 保存退出。 给post-commit 执行权限： 1chmod 755 post-commit]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7-Lnmp]]></title>
    <url>%2F2017%2F08%2F04%2Fcentos7-Lnmp%2F</url>
    <content type="text"><![CDATA[线上环境centos 7.2 x64 更新yum源1yum update 安装nginx 因为centos 不支持 yum安装 nginx，需要先添加 nginx 的yum 源。 1rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx 1yum install nginx 安装mysql 更新MySQL地址 1rpm -ivh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 安装 1yum install mysql-community-server 安装完毕后，在 /var/log/mysqld.log 文件中会自动生成一个随机的密码，我们需要先取得这个随机密码，以用于登录 MySQL 服务端 1grep "password" /var/log/mysqld.log OR 1mysql #直接登陆mysql 打印如下内容： 1A temporary password is generated for root@localhost: hilX0U!9i3_6 我们复制 root@localhost: 后面的随机字符串，这个字符串就是 MySQL 在安装完成后为我们随机生成的密码； 登录到 MySQL 服务端并更新用户 root 的密码 1mysql -u root -philX0U!9i3_6 打印出 MySQL 的版本即表明已登录；设置用户 root 可以在任意 IP 下被访问： 1grant all privileges on *.* to root@"%" identified by "新密码"; 刷新权限使之生效： 1flush privileges; 安装PHP 安装php的yum源 12rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装php5.5 1yum install php55w.x86_64 php55w-cli.x86_64 php55w-common.x86_64 php55w-gd.x86_64 php55w-ldap.x86_64 php55w-mbstring.x86_64 php55w-mcrypt.x86_64 php55w-mysql.x86_64 php55w-pdo.x86_64 安装php5.6 1yum install php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 安装php7 1yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 安装php-fpm 123yum install php55w-fpm yum install php56w-fpm yum install php70w-fpm]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>aliyun</tag>
        <tag>lnmp</tag>
      </tags>
  </entry>
</search>
